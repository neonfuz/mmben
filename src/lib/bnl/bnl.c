#include <SDL2/SDL.h>
#include "../c-vector/vec.h"
#include "bnl.h"

static
Token_type get_tok_type(char c) {
    switch (c) {
    case '(':  return TOK_LPAR;
    case ')':  return TOK_RPAR;
    case '<':  return TOK_LBR;
    case '>':  return TOK_RBR;
    case ' ':
    case '\n':
    case '\t':
    case '\0': return TOK_NULL;
    default:   return TOK_SYM;
    }
}

static
Token_vec lex_bnl(const char *bnl) {
  Token_vec tokens = vector_create();

  Token *t = vector_add_asg(&tokens);
  t->type = TOK_NULL;
  t->start = 0;
  t->length = 0;

  int i=0;
  do {
    Token_type nexttype = get_tok_type(bnl[i]);
    if (nexttype != t->type) {
      if (t->type != TOK_NULL) {
        t->length = i - t->start;
        t = vector_add_asg(&tokens);
      }
      t->type = nexttype;
      t->start = i;
    }
    ++i;
  } while (bnl[i-1]); // i-1 here to process final \0
  vector_pop(tokens); // remove final TOK_NULL token generated by the \0

  return tokens;
}

static
void Token_print(Token t, char *body) {
  printf("%4d %2d %.*s\n",
         t.start, t.length,
         t.length, t.start + body);
}

Lexed BNL_lex(char *bnl) {
  return (Lexed){
    .body = bnl,
    .tokens = lex_bnl(bnl),
  };
}

void Lexed_print(Lexed lexed) {
  int length = vector_size(lexed.tokens);
  for (int i=0; i<length; ++i)
    Token_print(lexed.tokens[i], lexed.body);
}

static
AST parse(Lexed l) {
  AST ast = { vector_create(), l.body };
  Object *obj = vector_add_asg(&ast.objs);
  obj->type = OBJ_NULL;
  for (unsigned t=0; t<vector_size(l.tokens); ++t) {

  }
  return ast;
}

AST BNL_Parse(char *bnl) {
  return parse(BNL_lex(bnl));
}
